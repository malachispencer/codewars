=begin
Codewars. 02/06/20. "Interleaving Arrays". 5kyu. Here we create a method that accepts an arbitrary number of arrays and returns a single
array generated by alternately appending elements from the passed in arrays. If one of the arrays is shorter than the others, the array
should be padded with nils. Here is the solution I developed to solve the challenge.
1) We define our method interleave_ms, which takes any number of arrays as its argument, so we use a splat argument.
2) First we find the maximum array length and store this in a variable m. We do so my mapping over args - which is an array of all our
   input arrays - and converting each array to its size, then taking the max.
3) Now we know the maximum array size, we can pad any arrays shorter than the max array size with nil values. So we map over args and if
   the size of the sub-array is less than m, we add nil to s as many times as the difference between the size of s and m. If it's not
   less, we leave s the same.
4) Now that args is padded with nils, we flat_map over it and turn each array into an array of arrays where each sub-array contains one
   element and its index position, we do so using each_with_index. Using flat_map as opposed to map allows us to flatten all the original
   arrays so now all their contents merge into one array.
5) We now have an array of arrays featuring an element and its index position from its original array. So we call sort_by(&:last) to
   sort the array by its index positions, which places all 0 indexed element together, all 1 indexed elements together etc.
6) We then map over and remove the index positions.
7) Our multiple arrays have now been interleaved into a single array.
=end

def interleave_ms(*args)
  m = args.map(&:size).max
  args.map {|s| s.size < m ? (m - s.size).times {s << nil} : s}
  args.flat_map {|s| s.each_with_index.to_a}.sort_by(&:last).map(&:first)
end

=begin
Here is another solution, submitted by a Codewars user, this is the shortest solution.
1) We create a range of the index of the maximum sized array from our input and we flat_map over that range or we flat_map 0 up to but
   not including 0. The latter prevents us getting a "bad value for range" error in some of the random tests.
2) As we flat_map the index of the max array, we map over args and convert that range index into the corresponding element in each array
   of args. If there is no element at that index of the given array, it will return a nil value, which means our new array is padded with
   nils.
3) If we mapped instead of flat mapping, we'd have an array of arrays where each array contains the elements at position i in each array
   of args, flat_map flattens this into our interleaved array.
4) If our input is [1,2,3], [4,5]. Our range is 0 to 2. At 0, we map over args and grab each 0 i.e. [1,4]. At 1, we map over args and grab
   each 1 i.e. [2,5]. At 2, we map over args and grab each 2, but there is no element at 2 in the second array, so we get [3, nil].
=end

def interleave(*args)
  (0... args.map(&:size).max || 0).flat_map {|i| args.map{|s| s[i]}}
end

=begin
Here is one more solution, submitted by Jesus Castello.
1) We return an empty array if args is empty, this is necessary in this method.
2) We store the size of the maximum array in args in a variable m. This time we use the max_by(&:size) method to select the largest array,
   then we take its size.
3) Now we handle our nil padding, we map! over args and to each we add a new array containing an amount of nil values that is the difference
   between m and the size of the array. If the array is the size of m, nothing is added, if it's less, the difference is added.
4) When we generate a new array using the Array.new() syntax, inside the argument the size is should be is always placed, then in the
   block we can fill the new array with default values.
5) Now args is padded with nil values. We call the zip method on the first array in args, then zip in the rest of the arrays in args, we
   need to use the splat argument to do so.
6) We flatten the new array, and now we have an interleaved array. 
=end

def interleave_x(*args)
  return [] if args.empty?
  m = args.max_by(&:size).size
  args.map! {|a| a + Array.new(m - a.size) {nil}}
  args[0].zip(*args[1..-1]).flatten
end